
@{
    ViewBag.Title = "Theory";
    Layout = "~/Views/Shared/_Layout.cshtml";
}

<div class="jumbotron home home-fullscreen" id="home">
    <div class="mask"></div>
    <a href="#" class="logo">
        <img src="~/Content/IMG/96x96.png" alt="Moderno - Theme by GraphBerry.com">
    </a>
    <!-- Offsite navigation -->
    <div class="container">
        <div class="header-info">
            <h1>ШУМОЗАЩИТНО КОДИРАНЕ</h1>
            <p>
                кодиране на информацията с цел с запазването и при предаването в каналите за връзка.
            </p>
            <a href="/Coding/Coding" class="btn btn-primary">ОЩЕ>></a>
        </div>
    </div>
</div>
<!-- Services section start -->
<!-- Services section end -->
<!-- Portfolio section start -->
<section id="portfolio" class="darker">
    <div class="container">
        <div class="panel panel-default" style="margin-right:2.5%;">
            <div class="panel-body">
                <h2>Код на Шенън Фано</h2>
                <br />
                <p align="justify">  Втората световна война дава силен тласък на развитието на кодирането във всяко едно от трите основни направления: шумозащитно кодиране, 
                криптиране и компресиране. Правят се редица изследвания и теоретични разработки, като постепенно започва да си проправя път идеята, 
                че за ефективното кодиране на едно съобщение е достатъчно да се знае вероятността на срещане на всеки от символите в него. 
                По това време се достига и до идеята за използването на двоичната бройна система като основа на кодиращия алгоритъм. 
                Последното представлява наистина сериозен пробив, особено предвид на факта, че по това време все още няма компютри. 
                Първият универсален ефективен алгоритъм за кодиране е разработен от Клод Шенън и M. Фано, като двамата го предлагат почти едновременно и независимо 
                един от друг.
                </p>

                <p align="justify">Основната идея на алгоритъма е по зададени вероятности на срещане на всеки от символите във входното съобщение да се съпостави двоичен код. 
                Алгоритъмът притежава следните характерни свойства:
                </p>

                <p align="justify">1. Дължината на кодовете е променлива (кода е неравномерен).</p>
                <p align="justify">2. Буквите с по-голяма вероятност се кодират с по-малко битове от тези с по-малка вероятност.</p>
                <p align="justify">3. Съобщението се декодира еднозначно</p>

                <h3>Предимства:</h3>
                <p align="justify">Когато кодираме по-често срещаните символи с по-къси битови последователлности, а по-рядко срещаните с по-дълги битови последователности, 
                    получаваме по-добри резултати по отношение на дължината на предаваното съобщение.
                </p>
                <h3>Недостатъци:</h3>
                <p align="justify">Основен недостатък на неравномерните кдове е чувствителността им към грепни битове. При тях един погрешен бит може да доведе до грешно или 
                    невъзможно декодиране на цялото съобщение докрая. Докато при равномерните кодове при един сгрешен бит води до повреждане на само един символ.
                    </p>

                <h3>Теорема:</h3> 
                 <p align="justify">Ако `I=(A;p_1≥p_2≥⋯≥p_n)` е източник на информация съществува оптимален префиксен код `k_0 ∶A→{0,1}^+` с дължина на кодовите думи `l_01≤l_02≤⋯≤l_(0n-1)= l_0n`, 
                    като кодовите думи `k_(0n-1)` и `k_0n` имат вида `k_(0n-1)= α0, k_0n= α1`.</p>

                <h3>Теорема: </h3>
                   <p align="justify"> Ако `k={k_1,k_2,…,k_n}`  с дължина на кодовите думи `l_1,l_2,…,l_n` е оптимален код за източника `I=(A;p_1≥p_2≥⋯≥p_n)` и вероятност `p_i` се представя във 
                       вида `p_i=q_1+q_2`, като `p_n≥q_1≥q_2`, тогава `k^'={k_1,…,k_(i-1),k_(i+1),…,k_n,k_i 0,k_i 1}` е оптимален код за 
                       източника `I^'={B;p_1≥⋯≥p_(i-1)≥p_(i+1)≥⋯≥p_n≥q_1≥q_2}` , където  B  е произволна азбука сn+1 букви.</p>
                <br />
                <h3>Алгоритъм:</h3>
                <br />
                <p align="justify">
                    Построението на оптималния код за източника  `I=(A;p_1,p_2,…,p_n)`  се осъществява при изпълнение на следния алгоритъм:
                   1. Множеството от символите на източника A се разполага по реда на намаляване на вероятностите за появяване на съобщенията - p_i.
                </p>
                <p align="justify">
                    2. Множеството от вероятностите P_i се разбива на две групи `(p_1,p_2,…,p_j )`   и `(p_(j+1),p_(j+2),…,p_m )`,
                    така че разликата  `|∑_(i=1)^j p_i - ∑_(i=j+1)^m p_i |` да е минимална.
                </p>
                <p align="justify">
                    На символите, чиито вероятности са е първата група - `(p_1,p_2,…,p_j )` се присвоява r-та кодова буква 0, а на тези от втората
                    група - `(p_(j+1),p_(j+2),…,p_m )`, r-та
                    кодова буква .
                </p>
                <p align="justify">
                    3.За група от вероятности с един елемент, процедурата завършва, а за всяка от останалите групи в многостъпковата процедура елементите се означават
                    с номера от 1 до m и се преминава рекурсивно `(r = r + 1)` към стъпка 2.
                </p> 
                <p align="justify">
                    Алгоритъмът на Шенън-Фано съпоставя на всеки източник кореново двоично дърво. Всички върхове, с изключение на корена, съответстват на подмножества от
                    вероятности на букви, които имат еднакви първи  r  кодови букви в кода, изграждан от алгоритъма. Левият и десен син на съответния връх са
                    подмножествата от вероятности на букви на съпоставеното му множество, които имат за `r + 1` – ва кодова буква съответно 0 и 1.
                </p>

                <br />
                <h3>Пример</h3>
                <br />
                <h4>Кодиране</h4>
                <br />
                <p align="justify">
                    Дадено е входно съобщение: ДНЕС Е ПРЕКРАСЕН ДЕН</p>
                  <p align="justify">  1)	Извършва се честотен анализа на символите (в лексикографска последователност). На Таблицата е показан честотния анализ.
                </p>
                    <br/>
                <img class="center-block img-thumbnail" src="~/Content/IMG/Table1.1.png" alt="Moderno - Theme by GraphBerry.com">
                    <br/>
                <p align="justify">  2)	Прави се разбиване по групи</palign="justify">
                <p align="justify"> 3)	Присвояват се съответно 0 или 1</p>
                <p align="justify"> 4)	Всеки символ има съответстващ бинарен еквивалент. На Таблицата е показан пълният процес за получаване на бинарните последователности.</p>
                <br />
                <img class="center-block img-thumbnail" src="~/Content/IMG/Table1.2.png" alt="Moderno - Theme by GraphBerry.com">
                <br />
                <p align="justify"> Кодиращото дърво на Шенън - Фано е показано на Фигурата.</p>
                <br />
                <img class="center-block img-thumbnail" src="~/Content/IMG/ShFTree.png" alt="Moderno - Theme by GraphBerry.com">
                <br />
                <p align="justify">  От тук се вижда че кодираното входно съобщение е : `100011001100100001011111101001111010111101100001101010000011`</p>
                <br />
                <h4> Декодиране:</h4>
                <br />
                <p align="justify">За реализация на декодирането са нужни:</p>
                <p align="justify">•	Кодираното с Алгоритъм на Шенън – Фано съобщение</p>
                <p align="justify">•	Кодиращо дърво на Шенън - Фано, построено при кодиране на съобщението.</p>
                <p align="justify">  Дадени са:</p>
                <p align="justify"> съобщение : `100011001100100001011111101001111010111101100001101010000011`</p>
                <p align="justify"> Кодиращо дърво от примера за кодиране</p>
                <p align="justify"> 1)	Входното съобщение се обхожда, като се взема всеки пореден бит – Input[i].</p>
                <p align="justify"> 2)	Дътвото се обхожда – от корена към листата в посока определена от текущия бит, докато се стигне до листо (I се увеличава с единица на всеки възел).</p>
                <p align="justify">	    -Ако Input[i] има стойност 0 се избира левия клон на поддървото</p>
                <p align="justify">     -Ако Input[i] има стойност 1 се избира десния клон на поддървото</p>
                <p align="justify"> 3)	Записва се символната стойност от листото.</p>
                <p align="justify"> 4)	Ако не е достигнат последният бит от входното съобщение: i се увеличава с единица и се преминава към стъпка 2</p>
                <p align="justify"> 5)	Ако е достигнат последния бит от входното съобщение, то вече е декодирано.</p>
                <br />
                <img  class="center-block img-thumbnail" src="~/Content/IMG/Table1.3.png" alt="Moderno - Theme by GraphBerry.com" style="display: block">
                <br />
                <p align="justify">  От Таблицата се вижда обхождането на входното съобщение и посоката на обхождане на кодиращото дърво. В последната колона на таблицата е записана символната последователност отговаряща на входното съобщение. Декодираното съобщение е ДНЕС Е ПРЕКРАСЕН ДЕН.</p>
</div>
        </div>
    </div>
</section>
<!-- Contact section end -->
<!-- Footer start -->

