
@{
    ViewBag.Title = "Coding";
    Layout = "~/Views/Shared/_Layout.cshtml";
}

<div class="jumbotron home home-fullscreen" id="home">
    <div class="mask"></div>
    <a href="#" class="logo">
        <img src="~/Content/IMG/96x96.png" alt="Moderno - Theme by GraphBerry.com">
    </a>
    <!-- Offsite navigation -->
    <div class="container">
        <div class="header-info">
            <h1>ШУМОЗАЩИТНО КОДИРАНЕ</h1>
         
    <a href="/Coding/Coding" class="btn btn-primary">ОЩЕ>></a>
</div>
    </div>
</div>
<!-- Services section start -->
<!-- Services section end -->
<!-- Portfolio section start -->
<section id="portfolio" class="darker">
    <div class="container">
        <div class="panel panel-default">
            <div class="panel-body">
                <h2>Шумозащитно кодиране</h2>
                <p align="justify">
                    Кодовете за защита от грешки се използват за коригиране на грешки при предаването на
                    съобщения през комуникационен канал, подложен на шумови въздействия. Бинарният поток
                    от данни (поток от нули и единици) следва да се предаде през зашумения канал бързо и надеждно.
                    Каналът може да бъде телефонна линия, високочестотна радиовръзка или сателитна комуникационна връзка.
                    Шумът може да се в резултат на операторна грешка, мълнии, топлинен шум, влошаване на работата на
                    съоръженията и т.н. и резултира в грешки, така че приетите данни се различават от изпратените.
                    Предназначението на кодовете за защита от грешки е да кодират данните чрез добавяне на определено
                    количество от излишна информация към съобщението, така че оригиналното съобщение да се възстанови,
                    ако се появят не много грешки. На Фигурата е показана Обобщената цифрова информациоона система.
                </p>
                <br />
                <img class="center-block img-thumbnail" src="~/Content/IMG/Picture5.1.png" alt="Moderno - Theme by GraphBerry.com">
                <br />
                <h3> Дефиниция: </h3>
                <p align="justify">
                    <math>`q`</math>-ичен код е множество от последователности от символи, където всеки символ е избран
                    от множество <math>`F_q={λ_1,λ_2,…,λ_q}`</math> от <math>`q`</math> отделни елементи. Множеството <math>`F_q`</math>  се нарича
                    азбука и често е множество от естествения ред на числата <math>`Z_q={0,1,2,…,q-1}`</math>.
                    Ако <math>`q`</math> е проста степен <math>`(q= p^h`</math>  за някое просто число <math>`p`</math> и положително 
                    цяло число <math>`h`</math>),
                    азбуката <math>`F_q`</math> е крайно поле с ред <math>`q`</math>. Двоичният код се нарича бинарен код.
                </p>
                <h3>Дефиниция:</h3>
                <p align="justify">Код, в който всяка кодова дума е последователност от ограничен брой <math>`n`</math> символи се нарича блоков 
                код с дължина <math>`n`</math>.</p>
                <p align="justify">
                    Кодът <math>`С`</math> с <math>`М`</math> кодови думи с дължина <math>`n`</math> се записва като <math>`M`</math> × <math>`n`</math> – решетка,
                    чиито редове са кодовите думи на <math>`С`</math>.
                </p>
                <p align="justify">
                    Ако се вземе за пример бинарен код с повторение и дължина <math>`3`</math>. Допуска се, че  <math>`(F_q )^n`</math>
                    e множеството от всички подредени <math>`n`</math> – орки от вида <math>`a=a_1,a_2,…,a_n`</math>, където всяко <math>`a_i ∈ F_q`</math>.
                    Елементите на <math>`(F_q )^n`</math>   се наричат вектори или думи. Множеството <math>`(F_q )^n`</math>  е от ред <math>`q^n`</math>.
                    От тук <math>`q`</math> – ичният код с дължина  <math>`n`</math>  е подмножество на <math>`(F_q )^n`</math>.
                </p>
                <p align="justify">
                    За оценка на близостта на една кодова дума до друга кодова дума се въвежда функция на дистанцията върху <math>`(F_q )^n`</math>,
                    наречена Hamming разстояние.
                </p>
                <p align="justify">
                    Hamming разстояние,  <math>`d(x, y)`</math>,  между два вектора  <math>`x`</math>  и  <math>`y`</math>  на <math>`(F_q )^n`</math> е броят на позициите,
                    в които те се различават. Например, в <math>`(F_2 )^5`</math>  Hamming разстоянието <math>`d(00111, 11001) = 4`</math>,
                    а в <math>`(F_3 )^4- d(0122, 1220) = 3`</math>.
                </p>
                <p align="justify">   Hamming разстояние е стандартна функция или метрика, която удовлетворява следните три условия:</p>
                <p align="justify">  1. <math>`d(x, y) = 0`</math>, ако и само ако <math>`x = y`</math>.</p>
                <p align="justify">   2. <math>`d(x, y) = d(y, x)`</math> за всички <math>`x`</math>, <math>`y ∈ (F_q )^n`</math>.</p>
                <p align="justify">   3. <math>`d(x, y) ≤ d(x, z) + d(z, y)`</math> за всички <math>`x, y, z ∈ (F_q )^n`</math>.</p>
                <p align="justify">
                    Доказателството на условия <math>`1`</math> и <math>`2`</math> е тривиално. Третото условие,
                    известно като триъгълно неравенство, се доказва по следния начин. Hamming разстоянието <math>`d(x, y)`</math>
                    е минималният брой изменения на цифрите, което е необходимо да се сведе <math>`х`</math> към <math>`y`</math>.
                    Но  <math>`х`</math>  може да се сведе към  <math>`y`</math>  чрез извършване първо на <math>`d(x, z)`</math> изменения
                    (свеждайки  <math>`х`</math>  към <math>`z`</math>) и след това <math>`d(z, y)`</math> изменения (свеждайки  <math>`z`</math>  към <math>`y`</math>).
                    Следователно, <math>`d(x, y) ≤ d(x, z) + d(z, y)`</math>.
                </p>
                <h3>Задача на декодирането :</h3>
                <p align="justify">
                    Допуска се, че кодовата дума <math>`х`</math>, неизвестна за приемната страна, е предадена по комуникационния канал.
    Приетият вектор, въздействан от шум е <math>`y`</math>. Този вектор се декодира като кодова дума  <math>`х′`</math>, вероятно и като  <math>`х`</math>,
                    така че <math>`d(x′, y)`</math> да е по възможност минимално, което дефинира схемата на декодиране по най-близкия съсед.
                    Тази стратегия максимизира функцията на правдоподобие на декодера при корекцията на грешки при следните допускания:
                </p>
                <p align="justify">
                    1. Всеки предаден символ има една и съща вероятност да бъде приет грешно, равна на <math>`p < 0,5`</math>, където <math>`p`</math>
                    е вероятността на символната грешка на канала.
                </p>
                <p align="justify">  2. Ако символът е грешно приет, тогава всяка една от <math>`q – 1`</math> възможни грешки е еднакво вероятна.</p>
                <p align="justify">  Този канал се нарича <math>`q`</math> – ичен симетричен канал. Бинарен симетричен канал е показан на Фигурата.</p>
                <br />
                <img class="center-block img-thumbnail" src="~/Content/IMG/Picture5.2.png" alt="Moderno - Theme by GraphBerry.com">
                <br />
                <p align="justify">
                    Разглежда се бинарен симетричен канал, по който се предава кодова дума с дължина <math>`n`</math>.
                    Като се отчете, че вероятността всеки символ да бъде приет коректно е <math>`(1 – p)`</math>,
                    то вероятността, че няма да се допусне нито една грешка се определя с израза <math>`(1-p)^n`</math>.
                    Вероятността, че една грешка се случва в определена позиция е  <math>`(1-p)^(n-1)`</math>.
                    Вероятността, че приетият вектор има грешки точно в <math>`i`</math> определени позиции е 
                    <math>`(p)^i (1-p)^(n-i)`</math>. Тъй като
                    <math>`p < 0.5`</math>, то приетият вектор да бъде без грешки е по-вероятно, отколкото всеки друг вектор;
                    всеки приет вектор с една грешка е по-вероятен от колкото друг с две или повече грешки и т.н.
                    Оттук следва, че при бинарен симетричен канал декодирането по най-близкия съсед е декодиране по
                     максимално правдоподобие.
                </p>
                <p align="justify">
                    Важен параметър на кода <math>`С`</math>, дефиниращ коригиращите свойства на кода, е минималното 
                    разстояние <math>`d(С)`</math>.
                    Параметърът <math>`d(С)`</math> е най-малкото от всички разстояние между отделните кодови думи:
                </p>
                <br/>
                <p align="center">  <math>`d(С) = min{d(x, y) ⎜ x, y ∈ С, x ≠ y}`</math>.</p>
                <br />
                <h3>Теорема:</h3>
                <p align="justify"> 1. Кодът <math>`С`</math> може да открива до  <math>`s`</math>  грешки във всяка кодова дума, 
                ако е в сила неравенството <math>`d(С) ≥ s + 1`</math>.</p>
                <p align="justify">
                    2. Кодът <math>`С`</math> може да коригира до  <math>`t`</math>  грешки във всяка кодова дума,
                    ако е в сила неравенството <math>`d(С) ≥ 2t + 1`</math>.
                </p>
                <h3>Доказателство:</h3>
                <p align="justify">
                    1. Предполага се, че <math>`d(С) ≥ s + 1`</math> и в предадената кодова дума са въведени  <math>`s`</math>  и 
                    или по-малко грешки.
                    Приетият вектор не може да бъде друга различна кодова дума, оттук следва, че грешките могат да бъдат открити.
                </p>
                <p align="justify">
                    2. Предполага се, че <math>`d(С) ≥ 2t + 1`</math>, предадена е кодова дума  <math>`х`</math>, приет векторът  <math>`y`</math>,
                    в който се появяват  <math>`t`</math>  или по-малко грешки, така, че <math>`d(x, y) ≤ t`</math>. Ако <math>`х′`</math>
                    е кодова дума, различна от  <math>`х`</math>, тогава  <math>`d(x′, y) ≥ t + 1`</math>. 
                    Защото, в противен случай, <math>`d(x′, y) ≤ t + 1`</math>,
                    което предполага чрез триъгълното неравенство, че <math>`d(x, x′) ≤ d(x, y) + d(x′, y) ≤  2t`</math>, което е в
                    противоречие на <math>`d(С) ≥ 2t + 1`</math>. Следователно  <math>`x`</math>  е най-близката кодова дума до  
                    <math>`y`</math>  и декодирането
                    по най-близкия съсед коригира грешките.
                </p>

                <h3>Извод:</h3>
                <p align="justify">
                    Ако кодът  <math>`С`</math>  има минимално разстояние  <math>`d`</math>, тогава  <math>`С`</math>  може да 
                    се използва: - да открива до <math>`(d – 1)`</math>
                    грешки във всяка кодова дума; - да коригира до <math>`⌊((d – 1))/2⌋`</math> грешки във всяка кодова дума.
                </p>
                <p align="justify">
                    Може да се построи таблица, илюстрираща зависимостта на броя на откритите и коригираните на грешки от кодовото минимално
                    разстояние. Зависимостта е показана на Таблицата.
                </p>
                <br />
                <img class="center-block img-thumbnail" src="~/Content/IMG/Table5.1.png" alt="Moderno - Theme by GraphBerry.com">
                <br />
                <p align="justify">
                    Означението <math>`(n, M, d)`</math> – код, дефинира код с дължина  <math>`n`</math>, съдържащ  <math>`M`</math>
                    кодови думи и притежаващ минимално кодово разстояние  <math>`d`</math>.
                </p>
                <h3>  Дефиниция на основния проблем в теорията на кодирането</h3>
                <p align="justify">
                    Код <math>`( n, М, d)`</math> с добри свойства се отличава с малко <math>`n`</math> (за бърза трансмисия на съобщенията),
                    голямо <math>`М`</math> (за изпращане на различни съобщения) и голяма стойност на <math>`d`</math> (за да се коригират много грешки).
                    Това са противоречиви изисквания. Основен проблем в теорията на кодирането е да се оптимизира един от параметрите
                    <math>`n, M, d`</math> при известни стойности на другите два. Обикновено този проблем се свежда до намирането на найголямата
                    стойност на кода <math>`M`</math> при зададени дължина n и минимално разстояние <math>`d`</math>. Означава се с <math>`А_q (n, d)`</math>
                    с най-голямата стойност на <math>`М`</math>, за която съществува <math>`q`</math> – ичен <math>`(n, M, d)`</math> –код.
                </p>
                <h3>Дефиниция:</h3>
                <p align="justify">Два <math>`q`</math>-ични кода са еквивалентни, ако единият може да се получи от другия чрез комбинация на операции от следния тип:</p>
                <p align="justify">  1. Пермутации на позициите в кода.</p>
                <p align="justify">  2. Пермутации на символите, намиращи се на фиксирана позиция.</p>
                <p align="justify">
                    Пермутация на множеството <math>`S = {x1, x2, ... , xn}`</math> e изобразяване на <math>`S`</math> едно към едно върху себе си.
                    Пермутацията <math>`f`</math> се представя във вида
                </p>
                <br />
                <p align="center">  <math>` ( ((x_1),(x_2),...,(x_n)), (↓,↓,...,↓), (f(x_1),f(x_2),...,f(x_n) ))`</math></p>
                <br />
                <p>
                    Ако кодът се изобразява като <math>`M`</math> × <math>`n`</math> матрица, чиито редове са кодови думи, тогава операция от типа <math>`1`</math>,
                    съответства на пермутация (преподреждане) на колоните в матрицата, а операцията от типа <math>`2`</math> съответства на
                    преиндиксиране на символите, намиращи се в дадена колона.  Разстоянията между кодовите думи не се променят чрез такива
                    операции. По този начин еквивалентните кодове имат еднакви параметри <math>`(n, M, d)`</math> и  коригират един същ брой на
                    грешките. В случай на <math>`q`</math>-ичен симетричен канал, действието на еквивалентните кодове ще бъде идентично по
                    отношение на вероятностите за корекция на грешките.
                </p>
                <h3>Лема:</h3>
                <p align="justify">
                    Всеки <math>`q`</math> – ичен <math>`(n, M, d)`</math>-код върху азбуката <math>`{0, 1, 2, ..., q – 1}`</math> е еквивалентен на <math>`(n, M, d)`</math>-код,
                    който съдържа нулев вектор <math>`0 = 0 0 ...0`</math>.
                </p>
                <h3>Доказателство:</h3>
                <p align="justify">  Избира се някаква кодова дума <math>`x_1,x_2,…,x_n`</math>. За всяко <math>`x_i ≠ 0`</math> се прилага пермутацията</p>
                <br />
                 <p align="center">  <math>`((0,(x_i),j),(↓,↓,↓),((x_i),0,j))`</math></p>
                <br />
                <p align="justify">   за всяко <math>`j ≠ 0`</math>, <math>`x_i`</math>, към символите от позиция <math>`i`</math>.</p>
                <h3>Лема:</h3>
                <p align="justify">Ако <math>`x`</math>  и <math>`y ∈ (F_2 )^n`</math>, тогава  <math>`d(x, y) = w(x + y)`</math>.</p>
                <h3>Теорема:</h3>
                <p align="justify">
                    Ако <math>`d`</math>  е нечетно число бинарният <math>`(n, M, d)`</math>-код съществува, тогава и само тогава, ако
                    съществува бинарният код <math>`(n + 1, M, d + 1)`</math>.
                </p>
                <p align="justify">
                    Нека кодът <math>`C ̂ е`</math> код с дължина <math>`(n + 1)`</math>, получен от <math>`С`</math> чрез удължаване на всяка кодова дума
                    <math>`x`</math> на <math>`С`</math> в съответствие с правилото за добавяне на общи проверовъчни елементи:
                </p>
                <p align="justify">  <math>`x= x_1,x_2,…,x_n→x ̂= `</math> <math>`{(x_1,x_2,…,x_n  0,  ако  w(x)  е четно;),(x_1,x_2,…,x_n  1, ако   w(x)   е нечетно;))`</math></p>
                    <p align="justify">
                        Еквивалентно може да се запише  <math>`x ̂= x_1  x_2… x_n,x_(n+1)`</math> където <math>`x_(n+1)= ∑_(i=1)^n x_i`</math>
                        се изчислява по модул <math>`2`</math>.
                    </p>
                    <h3>Извод:</h3>
                    <p align="justify">   Ако  <math>`d`</math>  е нечетно, тогава <math>`A_2 (n + 1, d + 1) = A_2 (n, d)`</math>.</p>
                    <p align="justify">   Ако  <math>`d`</math>  е четно, тогава <math>`A_2 (n, d) = A_2 (n – 1, d – 1)`</math>.</p>
                    <h3>Дефиниция:</h3>
                    <p align="justify">
                        За всеки вектор <math>`u`</math> в пространството <math>`(F_q )^n`</math>, и всяка цяло число <math>`r ≥ 0`</math>, сферата с радиус <math>`r`</math> и център
                        u`
                </math>, означена с <math>`S(u, r)`</math>, е множеството <math>`{v ∈ (F_q )^n⎜d(u, v) ≤ r}`</math>.
                </p>
                <p align="justify">
                    Ако <math>`d(C) ≥ 2t + 1`</math>, тогава сферите с радиус <math>`t`</math>, центрирани върху кодовите думи от <math>`С`</math> са несъвпадащи,
                    т.е. те не се препокриват. Ако векторът <math>`y`</math> беше в двете сфери <math>`S(x, t)`</math> и <math>`S(x′, t)`</math>
                    за кодовите думи <math>`x`</math> и <math>`x′`</math>, тогава в съответствие с триъгълното неравенство може да се запише:
                </p>
                <p align="justify">   <math>`d(x, x′) = d(x, y) + d(x′, y) ≤ t + t = 2t`</math>,  което е в противоречие с твърдението, че:</p>
                <p align="justify">   <math>`d(C) ≥ 2t + 1`</math>.</p>
                <p align="justify">
                    Следователно, ако <math>`t`</math> или повече грешки се появят в кодовата дума <math>`x`</math>, тогава приетият вектор <math>`y`</math>
                    може да се различава от (да не съвпада с) центъра на сферата  <math>`S(x, t)`</math>, но не може да излезе извън сферата,
                    а се привлича обратно към <math>` x`</math> чрез декодиране по принципа на найблизкия съсед.
                </p>
                <h3>Лема:</h3>
                <p align="justify">Сфера с радиус <math>`r`</math> в <math>`(F_q )^n (0 ≤ r ≤ n)`</math> съдържа точно <math>`(n¦0)+(n¦1)  (q-1)+(n¦2) (q-1)^2+⋯+(n¦r) (q-1)^r`</math>  вектори.</p>
                <p align="justify">  Числата <math>`(n¦m)`</math> се наричат биномни коефициенти в съответствие с биномната теорема</p>
                <br />
                 <p align="center">  <math>`(1+x)^n=1+(n¦1)  x+(n¦1) x^2+⋯+ (n¦n) x^n`</math></p>
                <br />
                <p align="justify">
                    За всяко цяло число <math>`x`</math>, чрез полагане <math>`x = q – 1`</math>  и   <math>`r = n`</math>, множеството <math>`S(u, n)`</math>
                    е цялото пространство <math>`(F_q )^n`</math> и съдържа <math>`q^n = (1+x)^n`</math> вектори.
                </p>
                <h3>Перфектни кодове</h3>
                <p align="justify">
                    Кодът, който достига границите на сферичната опаковка, т.е. реализира се равенство в (1), се нарича перфектен код.
                    Следователно, за перфектен коригиращ <math>`t`</math> грешки, <math>`M`</math> сфери с радиус <math>`t`</math>, центрирани върху кодовите думи,
                    изпълват цялото кодово пространство <math>`(F_q )^n`</math> без препокриване. С други думи, всеки вектор в <math>`(F_q )^n`</math>
                    е на разстояние <math>`≤ t`</math> от точно една кодова дума.  Бинарният код с повторение:
                </p>
                <br />
                <p align="center">  <math>`{(0,0,…,0),(1,1,…,1))`</math></p>
                <br />
                <p align="justify">
                    с дължина <math>`n`</math>, където <math>`n`</math> е нечетно, е перфектен <math>`(n, 2, n)`</math>-код.
                    Такива кодове, съвместно с кодовете, които съдържат само една кодова дума или които са цялото пространство
                    <math>`(F_q )^n`</math>, са известни като тривиални перфектни кодове.
                </p>
            </div>
        </div>
    </div>
</section>
<!-- Contact section end -->
<!-- Footer start -->

