
@{
    ViewBag.Title = "Theory";
    Layout = "~/Views/Shared/_Layout.cshtml";
}

<div class="jumbotron home home-fullscreen" id="home">
    <div class="mask"></div>
    <a href="#" class="logo">
        <img src="~/Content/IMG/96x96.png" alt="Moderno - Theme by GraphBerry.com">
    </a>
    <!-- Offsite navigation -->
    <div class="container">
        <div class="header-info">
            <h1>ШУМОЗАЩИТНО КОДИРАНЕ</h1>
            <p>
                кодиране на информацията с цел с запазването и при предаването в каналите за връзка.
            </p>
            <a href="/Coding/Coding" class="btn btn-primary">ОЩЕ>></a>
        </div>
    </div>
</div>
<!-- Services section start -->
<!-- Services section end -->
<!-- Portfolio section start -->
<section id="portfolio" class="darker">
    <div class="container">
        <div class="panel panel-default" style="margin-right:2.5%;">
            <div class="panel-body">
                <h2>Систематична форма</h2>
                <p align="justify">  Два линейни кода върху <math>`GF(q)`</math> са еквивалентни ако единия може да се получи от другия чрез следните операции: </p>
                <p align="justify">
                    Пeрмутации на позициите в кода.
                </p>
                <p align="justify">
                    Умножение на символите, появяващи се във фиксирана позиция с нулев скалар.
                </p>
                    <h3>Теорема: </h3>
                <p align="justify">
                    Две <math>`k×n`</math> матрици генерират еквивалентни линейни кодове <math>`[n, k]`</math> кодове върху <math>`GF(q)`</math>, 
                    ако едната матрица може да се получи от другата чрез следните операции:
                </p>
                <p align="justify">
                    Пермутации  на редовете.
                </p>
                <p align="justify">
                    Умножение на ред с ненулев скалар.
                </p>
                <p align="justify">
                    Добавяне на скаларно умножение на един ред с друг ред.
                </p>
                <p align="justify">
                    Пермутация на колоните.
                </p>
                <p align="justify">
                    Умножение на една колона с ненулев скалар.
                </p>
                    <h3>Теорема:</h3>
                <p align="justify">
                    Чрез прилагане на правилата <math>`1, 2, 3, 4, 5`</math> (от предходната теорема) пораждащата матрица на <math>`[n, k]`</math> код 
                    се преобразува в систематичен вид <math>`[I_k,A]`</math>, където <math>`I_k`</math> е <math>`k×k`</math> единична матрица, а <math>`А`</math> е <math>`k×(n-k)`</math> матрица.
                </p>
                <p align="justify">
                    Най-общо, за да се приведе матрицата в систематичен вди се прилага метода на Гаус-Жордан за получаване на долнотриъгълна матрица.
                </p>
                <p align="justify">
                    За определянето на линейните кодове освен методът на генераторната матрица, се използва методът и на проверовъчната матрица.
                </p>
                    <h3>Дефиниция:</h3>
                <p align="justify">
                    Скаларно произведение <math>`u . v`</math> на векторите <math>`u=u_1 u_2  … u_n`</math> и <math>`v=v_1 v_2  … v_n`</math> в <math>`V(n,q)`</math> 
                    е скаларът (т.е. елемент от <math>`V(n,q)`</math>), дефиниран чрез <math>`u.v= u_1 v_1+ u_2 v_2  + … u_n v_n`</math>.
                </p>
                    <h3>Лема:</h3>
                <p align="justify">
                    За всяко <math>`u`</math>,  <math>`v`</math> и <math>`w`</math> в <math>`V(n,q)`</math> и  <math>`λ, μ ∈ GF(q)`</math>,
                </p>
                <p align="justify"> 1. <math>`u . v = v . u`</math> </p>
                <p align="justify">  2. <math>`(λ u  +  μ v) .w  = λ (u . w) + μ (v.w)`</math> </p>
                <p align="justify">
                    Ако е зададен линеен <math>`[n, k]`</math> – код <math>`С`</math>, то ортогоналният код на <math>`С`</math>, който се означава <math>`C^⊥`</math> 
                    дефинира множество от тези вектори на <math>`V(n, q)`</math>, които са ортогонални на на всяка кодова дума от 
                    <math>`С`</math>, т.е.  <math>`C^⊥ = {v ∈ V(n, q)⎜v . u = 0, Ѵ u ∈ C}`</math>.
                </p>
                    <h3>Лема:</h3>
                <p align="justify">
                    Нека <math>`С`</math> е <math>`[n, k]`</math>-код с пораждаща матрица <math>`G`</math>. Тогава векторът <math>`v`</math> от <math>`V(n, q)`</math> принадлежи 
                    на <math>`C^⊥`</math>, тогава и само тогава, когато <math>`v`</math> е ортогонален на всеки ред от <math>`G`</math>, т.е. <math>`v ∈ C^⊥ ⇔vG^T = 0`</math>,
                    където <math>`G^T`</math> означава транспонирана матрица на <math>`G`</math>.
                </p>
                    <h3>Теорема:</h3>
                <p align="justify">
                    Допуска се че <math>`С`</math> е <math>`[n, k]`</math>-код върху <math>`GF(q)`</math>. Тогава ортогоналният код <math>`C^⊥`</math> на <math>`С`</math> е линеен <math>`[n, n - k]`</math>-код.
                </p>
                <p align="justify">
                    Ако <math>`C_1`</math> и <math>`C_2`</math> са еквивалентни, то <math>`C_1^⊥`</math> и <math>`C_2^⊥`</math> са също еквивалентни.
                    Достатъчно е да се покаже, че <math>`dim (C^⊥) = n – k`</math>, в случай че <math>`С`</math> има стандартна форма на пораждащата матрица.
                </p>
                <br />
                <p align="center">
                    <math>`((1,cdots,0,a_11,cdots,a_(1,n-k)),(vdots,ddots,vdots,vdots,ddots,vdots),(0,cdots,1,a_k1,cdots,a_(k,n-k)))`</math>
                </p>
                <br />
                <p align="justify">   Тогава <math>`C^⊥={(v_1,v_2,…,v_n)∈ V(n,q)│v_i+ ∑_(j=1)^(n-k) a_ij  v_(k+j)=0,i= bar(1,k)  }`</math> </palign="justify">
                <p align="justify">
                    За всеки от <math>`q^(n-k)`</math> избора на <math>`(v_(k+1),…,v_n)`</math> съществува единствен вектор <math>`(v_1,v_2,…,v_n)`</math>  в <math>`C^⊥`</math>. 
                    Следователно, <math>`|C^⊥|= q^(n-k)`</math> , а дименсията <math>`dim(C^⊥) =n - k`</math>.
                </p>
                    <h3>Дефиниция:</h3>
                <p align="justify">
                    Проверовъчна матрица <math>`H`</math> за <math>`[n, k]`</math>-код <math>`C`</math> е пораждаща матрица на <math>`C^⊥`</math>.
                </p>
                <p align="justify">
                    Матрицата <math>`H`</math> е <math>`(n - k) × n`</math>, матрица, удовлетворявайки уравнението <math>`GH^T  = 0`</math>, 
                    където <math>`H^T`</math> означава транспонираната на <math>`H`</math>, 0 е нулева матрица. От по-горе дефинираните лема 
                    и теорем следва, че ако <math>`H`</math> е проверовъчна матрица на  <math>`С`</math>, тогава  <math>`С = {x ∈ V(n, q)⎟ x.H^T = 0}`</math>.
</p>
                <p align="justify">
                    По този начин всеки линеен код е напълно определен чрез проверовчната матрица.
                </p>
                <p align="justify">
                    Редовете на проверовъчната матрица са проверовъчни елементи върху кодовите думи. 
                    Tе показват, че определени линейни комбинации от координатите на всяка кодова дума са нули. 
                    Кодът е изцяло определен чрез проверовъчната матрица.
                </p>
                    <h3>Теорема:</h3>
                <p align="justify">
                    Ако <math>`G = [I_k⎟ A]`</math> е пораждащата матрица със стандартна форма на <math>`[n, k]`</math> код <math>`C`</math>, 
                    тогава проверочната матрица за <math>`С`</math> има вида  <math>`H = [-А^T⎟ I_(n-k)]`</math>, където <math>`А^T`</math> е <math>`n – k × k`</math> – матрица.
                </p>
                    <h3>Дефиниция:</h3>
                <p align="justify">
                    Проверовъчната матрица <math>`H`</math> е в стандартна форма ако има вида  <math>`H = [B ⎟ I_(n-k)]`</math>.
                </p>
                <p align="justify">
                    Ако кодът е дефиниран с проверовъчна матрица в стандартна форма, която е във вида           
                    <math>`H = [B ⎟ I_(n-k)]`</math>, тогава пораждащата матрица за кода има вид  <math>`H = [I_k ⎟ B^T]`</math>. Много кодове, 
                    например, код на Hamming, се дефинират чрез проверочна матрица или, което е еквивалентно, 
                    чрез множество от проверовъчни уравнения. Ако кодът е зададен чрез проверовъчна матрица <math>`Н`</math>, 
                    която не е в стандартна форма, тогава <math>`Н`</math> може да се редуцира до стандартна форма по същия начин 
                    както се получава стандартна форма за генераторната матрица.
                </p>

                <h3>Алгоритъм:</h3>
                <p align="justify">1. Поражаща матрица на линеен код в систематичен вид има следния вид: <math>`G_KxN=( I │ A )`</math>, където <math>`I`</math> е единичната матрица, а <math>`A`</math> е произволна двоична матица.</p>
                <p align="justify">2. Проверява се дали вхоната матица е в систематичен вид.</p>
                <p align="justify"> -Ако не е се привежда в систетематичена вид, като се използава метода за решаване а матрица на Фаус – Жордан.</p>
                <p align="justify"> -Ако е се преминава към стъпка 2.</p>
                <p align="justify">3. Образува се проврочната матрица H, която има вида: <math>`H= ( A^T │ I )`</math>, където  <math>`A^T`</math> е транспонираната матрица <math>`А`</math>, а <math>`I`</math> е единичната матрица.</p>
                <p align="justify">4. Получената матрица <math>`H`</math> е проверовъчна матрица в систематичен вида, на кода породен от матрицата <math>`G`</math>.</p>
                <h3>Пример:</h3>
                <p align="justify"> Входна матрица – пораждаща матрица на линейния код (матрицата не е в систематичен вид):</p>
                <br />
                <p align="center"> <math>`G=((0,0,0,1,1,1,1),(0,1,1,0,0,1,1),(1,0,1,0,1,0,1))`</math></p>
                <br />
                <p align="justify"> Привеждаме матрицата в систематичен вид. За целата</p>
                <p align="justify"> Разменят се първи и трети стълб</p>
                <p align="justify"> Разменят се първи ичетвърти стълб</p>
                <p align="justify"> Получава се пораждаща матрица в систематичен вид:</p>
                <br />
                <p align="center"> <math>`G=((1,0,0,0,1,1,1),(0,1,0,1,0,1,1),(0,0,1,1,1,0,1))`</math></p>
                <br />
                <p align="justify"> Първата част на <math>`G`</math> е единичната матрица, а втората част – матрицата <math>`A`</math>.</p>
                <p align="justify">Образува се проверочната матрица <math>`H`</math>:</p>
                <p align="justify"> Матрицата <math>`А`</math> се транспонира и се записва в началото на проверочната матрица <math>`H`</math>.</p>
                <p align="justify"> Втората част на <math>`H`</math> се дописва с единичната матрица.</p>
                <br/>
                <p align="center"> <math>`H=((0,1,1,1,0,0,0),(1,0,1,0,1,0,0),(1,1,0,0,0,1,0),(1,1,1,0,0,0,1))`</math></p>
                <br />
                <p align="justify"> Проверочната матрица  в сивтематичен вид е получена.</p>

            </div>
        </div>
    </div>
</section>
<!-- Contact section end -->
<!-- Footer start -->

