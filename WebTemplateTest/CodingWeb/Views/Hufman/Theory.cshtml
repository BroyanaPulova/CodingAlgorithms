
@{
    ViewBag.Title = "Theory";
    Layout = "~/Views/Shared/_Layout.cshtml";
}

<div class="jumbotron home home-fullscreen" id="home">
    <div class="mask"></div>
    <a href="#" class="logo">
        <img src="~/Content/IMG/96x96.png" alt="Moderno - Theme by GraphBerry.com">
    </a>
    <!-- Offsite navigation -->
    <div class="container">
        <div class="header-info">
            <h1>ШУМОЗАЩИТНО КОДИРАНЕ</h1>
            <p>
                кодиране на информацията с цел с запазването и при предаването в каналите за връзка.
            </p>
            <a href="/Coding/Coding" class="btn btn-primary">ОЩЕ>></a>
        </div>
    </div>
</div>
<!-- Services section start -->
<!-- Services section end -->
<!-- Portfolio section start -->
<section id="portfolio" class="darker">
    <div class="container" >
        <div class="panel panel-default" style="margin-right:2.5%;">
            <div class="panel-body">
                <h2>Код на Хъфман</h2>
                <p align="justify"> Хъфман успява да избегне недостатъците на алгоритъма на Шенън-Фано, като строи дървото от листата към корена.
                1. От всеки символ се образува тривиално дърво, в корена на което записваме вероятността на срещане на съответния символ.
                2. Намират се двата върха с най-малки вероятности и се обединяваме в ново дърво с корен, съдържащ сумата от вероятностите им.
                3. Ако има поне две дървета, преход към 2.
                Алгоритъмът на Хъфман строи дърво със същите свойства като изгражданото от алгоритъма на Шенън-Фано. Търсеният код, както и декодирането на съобщението се 
                извършват абсолютно аналогично. Разликата е, че в дървото на Хъфман символите с по-голяма честота се включват по-късно в дървото. Така те се оказват 
                по-близо до корена, т. е. съпоставят им се по-кратки бинарни последователности.
                Най-важното свойство на дървото на Хъфман е, че винаги гарантира построяването на оптимален побуквен код, за разлика от алгоритъма на Шенън-Фано, който 
                понякога греши. Ако на някоя стъпка има повече от една възможности, се избира коя да е от тях. Алгоритъмът на Хъфман е добър пример за приложение на алчен 
                алгоритъм. Не е трудно да се докаже, че всички дървета на Хъфман, построени по едни и същи честоти, имат еднаква дължина на претегления външен път.
                </p>
                <h3>Алгоритъм</h3>
                <p align="justify"> Построението на оптималния код за източника  <math>`I=(A;p_1,p_2,…,p_n)`</math>  се осъществява при изпълнение на следния алгоритъм:</p>
                <p align="justify">От източника  I  се строят източниците <math>`I_(n-1), I_(n-2), … I_2 с n-1, n-1, … ,2`</math> букви на кодовите думи, като всеки път път се сумират 
                най-малките вероятности на текущия източник, като се записват от кои две стойности се е получила сумата.</p>
                <p align="justify">За източника <math>`I_2`</math> оптималният код се състои от думите  0  и  1.</p>
                <p align="justify">От оптималния код <math>`I_2`</math> се строят последователно оптималните кодове на източниците <math>`I_3, I_4, … , I_(n-1), I`</math>, 
                като кодовата дума, съответстваща на вероятността, получена като сума от двете най-малки вероятности от предния източник, се разширява отдясно с 0 и 1. 
                На получените две думи се присвояват най-малките вероятности на този източник. На всички останали думи се присвояват старите вероятности.</p>
                    <h4>Кодиране - двоично дърво на Хафман:</h4>
                <p align="justify">На стъпка 1 на върховете на двоичното дърво се преписва по една вероятност, а на стъпка 2 – по една дума при следните правила:</p>
                <h4>В права посока:</h4>
<p align="justify">1.	 Изобразяват се  n  върха, като  n   отделни дървета, с начални вероятности.</p>
    <p align="justify">2.	Всеки път, когато се сумират двете най-малки вероятности, присвоени на коренитедървета <math>`r_1`</math> и <math>`r_2`</math>, се избира нов връх - r, на който 
                се присвоява получената сума, като дърветата с корени <math>`r_1`</math> и <math>`r_2`</math> стават ляво и дясно поддърво на новия връх.</p>
    <p align="justify">3.	Когато се получат две поддървета, процедурата завършва, като на корена на полученото двоично дърво се присвоява числото 1.</p>
    <h4>В обратната посока:</h4>
    <p align="justify">1.	 На корена на двоичното дърво се приписва думата <math>`ε`</math>.</p>
    <p align="justify">2. 	Всеки път, когато на един връх се приписва думата  α , на левия му син се присвоява думата <math>`α_0`</math>, а на десния - <math>`α_1`</math>, докато по този 
                начин на всеки връх на дървото се присвоява дума.</p>
    <p align="justify"> 3.	Листата на полученото дърво са надписани с вероятностите на началния източник, а присвоените думи на всеки връх са думите на оптималния
        код за този източника – код на Хафман.</p>
    <h3>Пример:</h3>
            <h4> Кодиране:</h4>
                    <p align="justify">Дадено е входно съобщение: ДНЕС Е ПРЕКРАСЕН ДЕН</palign="justify">
                    <p align="justify">За кодирането ще се използва таблица, на която е направн честорен анализ на символите от входното съобщение:</p>
                <br/>
    <img class="center-block img-thumbnail" src="~/Content/IMG/Table1.1.png" alt="Moderno - Theme by GraphBerry.com">
                              <br />
    <p align="justify">На база честотния анализ се построява дървото на Хъфман: </p>
                              <br />
    <img class="center-block img-thumbnail" src="~/Content/IMG/Table2.1.png" alt="Moderno - Theme by GraphBerry.com">
                              <br />
    <p align="justify">От дървото се образуева кодираното съобщение, като символите от входните данни се заместят с получените симвли. Кодираното съобщение е:
                010110001010100001001111011001110011101110100011010001000110</p>
                <br />
                                  Декодиране:
    <p align="justify">За реализация на декодирането са нужни:</p>
    <p align="justify">•	Кодираното с Алгоритъм на Хъфман съобщение</p>
    <p align="justify">•	Кодиращо дърво на Хъфман, построено при кодиране на съобщението.</p>
                                  Дадени са:
    <p align="justify">съобщение  010110001010100001001111011001110011101110100011010001000110</p>
    <p align="justify">Кодиращо дърво от Фигура 1.8.</p>
    <p align="justify">1)	 Входното съобщение се обхожда, като се взема всеки пореден бит – Input[i].</p>
    <p align="justify">2)	Дътвото се обхожда – от корена към листата в посока определена от текущия бит, докато се стигне до листо (I се увеличава с единица на всеки възел).</p>
    <p align="justify">	Ако Input[i] има стойност 0 се избира левия клон на поддървото</p>
    <p align="justify">	Ако Input[i] има стойност 1 се избира десния клон на поддървото</p>
    <p align="justify">3)	Записва се символната стойност от листото.</p>
    <p align="justify">4)	Ако не е достигнат последният бит от входното съобщение: i се увеличава с единица и се преминава към стъпка 2</p>
    <p align="justify">5)	Ако е достигнат последния бит от входното съобщение, то вече е декодирано.</p>
                              <br />
    <img class="center-block img-thumbnail" src="~/Content/IMG/Table2.2.png" alt="Moderno - Theme by GraphBerry.com">
                              <br />
    <p align="justify">От таблицата се вижда обхождането на входното съобщение и посоката на обхождане на кодиращото дърво. В последната колона на таблицата е записана символната
    последователност отговаряща на входното съобщение. Декодираното съобщение е ДНЕС Е ПРЕКРАСЕН ДЕН.</p>

</div>
        </div>
    </div>
</section>
<!-- Contact section end -->
<!-- Footer start -->
