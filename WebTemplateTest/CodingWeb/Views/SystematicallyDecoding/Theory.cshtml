@{
    ViewBag.Title = "Theory";
    Layout = "~/Views/Shared/_Layout.cshtml";
}

<div class="jumbotron home home-fullscreen" id="home">
    <div class="mask"></div>
    <a href="#" class="logo">
        <img src="~/Content/IMG/96x96.png" alt="Moderno - Theme by GraphBerry.com">
    </a>
    <!-- Offsite navigation -->
    <div class="container">
        <div class="header-info">
            <h1>ШУМОЗАЩИТНО КОДИРАНЕ</h1>
            <p>
                кодиране на информацията с цел с запазването и при предаването в каналите за връзка.
            </p>
            <a href="/Coding/Coding" class="btn btn-primary">ОЩЕ>></a>
        </div>
    </div>
</div>
<!-- Services section start -->
<!-- Services section end -->
<!-- Portfolio section start -->
<section id="portfolio" class="darker">
    <div class="container">
        <div class="panel panel-default" style="margin-right:2.5%;">
            <div class="panel-body">
                <h2>Синдромно декодиране</h2>
                <p align="justify">
                    Допуска се, че H е проверовъчна матрица на <math>`[n, k]`</math>–код. Тогава за някакъв вектор <math>`y ∈ V(n, q)`</math>,
                     векторът-ред <math>`1 × (n - k)`</math> -> <math>`S (y)= y.H^Т`</math>  се нарича синдром на <math>`y`</math>.
                </p>
                <p align="justify"> 1. Ако редовете на <math>`Н`</math> са <math>`h_1,h_2,…,h_(n-k)`</math>, тогава:
                  <math>`S (y) = y.h_1,y.h_2,…,y.h_(n-k)`</math></p>
                <p align="justify"> 2. <math>`S (y) = 0 ⇔ y ∈ C`</math>.</p>

                <h3>Лема:</h3>
                <p align="justify"> Два вектора <math>`u`</math> и <math>`v`</math> се намират в едно комножество (съседно множество или клас) на <math>`С`</math>, 
                тогава и сано тогава когато те имат един и същ синдром.</p>

                <p align="justify"> Съществува взаимно-еднозначно съответствие между комножествата и синдромите.  
                При стандартното решетъчно декодиране, ако <math>`n`</math> има малка стойност лесно се локализира приеманият вектор <math>`y`</math> в решетката.
                 Но, ако <math>`n`</math> има голяма стойност, трудно се открива лидерът на ко-множество, който съдържа <math>`y`</math>.</p>
                <p align="justify">  Например за бинарния кода <math>`C[4, 2]`</math> с пораждаща матрица <math>`G=((1,0,1,1),(0,1,0,1))`</math> Стандартната решетка е показана в таблицата.:</p>
                <br />
                <img class="center-block img-thumbnail" src="~/Content/IMG/Table4.1.png" alt="Moderno - Theme by GraphBerry.com">
                <br />
                <h3>Декодиращ алгоритъм 1:</h3>
                <p align="justify">  1. Ако се приеме вектор <math>`y`</math>, се изчислява синдромът  <math>`S(y) = yH^Т`</math>.</p>
                <p align="justify"> 2. Определя се мястото на <math>`S(y)`</math> в колоната на синдромите на стандартната решетка.</p>
                <p align="justify">  3. Определя се мястото на <math>`y`</math> в съответния ред и се декодира като кодова дума, 
                която се намира на върха на колоната, която съдържа <math>`y`</math>.</p>
                <p align="justify">  При числена реализация на декодиране чрез стандартна решетка е необходимо да се запазят само две колони 
                (синдромите и лидерите на комножествата) в паметта на компютъра. Това се нарича синдромна претърсваща таблица. 
                Синдромната претърсваща таблица за кода от предходния пример е показана в таблицата:</p>
                <br />
                <img class="center-block img-thumbnail" src="~/Content/IMG/Table4.2.png" alt="Moderno - Theme by GraphBerry.com">
                <br />
                <h3> Декодиращ алгоритъм 2:</h3>
                <p align="justify">  1. За приетият вектор <math>`y`</math> се изчислява синдромът <math>`S(y) = yH^Т`</math>.</p>
                <p align="justify">   2. Нека  <math>`z = S(y)`</math> е синдромът. Определя се мястото на <math>`z`</math>  в първата колона на претърсващата таблица.</p>
                <p align="justify">   3. Декодира се <math>`y`</math> като <math>`y – f(z)`</math>.</p>
                <p align="justify">   Например, ако <math>`y = 1111`</math>, тогава <math>`S(y) = 01`</math>, а приетият вектор се декодира като</p>
                <p align="justify">   <math>`1111 – 0100 =1011`</math>.</p>
                <h3>Непълно декодиране:</h3>
                <p align="justify">  Това е комбинация от коригиране на грешката и откриване. Откриването се използва, когато коригирането 
                може да даде неправилна кодова дума.  Ако <math>`d(C) = 2t + 1`</math> или <math>`2t + 2`</math> се прилага следната схема, 
                с която се гарантира корекцията на <math>`≤ t`</math> грешки в някаква кодова дума и отриване на повече от <math>`t`</math> грешки.  
                Комножествата на стандартната решетка се аранжират, обикновено, по реда на нарастващото тегло на лидерите на комножествата, 
                като решетката се разделя на горна част, обхващаща тези комножества, чиито лидери имат тегла <math>`≤ t`</math> и на долна част, 
                обхващаща останалите комножества. Ако приетият вектор <math>`y`</math> е в горната част, то той се декодира, както обикновено 
                (допускайки <math>`≤ t`</math> грешки). Ако векторът <math>`y`</math> е в долната част, това означава, че повече от <math>`t`</math> 
                грешки са се появили, което изисква повторно предаване на съобщението.</p>
                <h3> Лидери на комножеството</h3>
                <p align="justify">   Ако се приеме <math>`11110`</math>, той се декодира като <math>`10110`</math>, но ако <math>`10011`</math> се приеме, се налага повторно 
                предаване на съобщението. Ако приетият вектор <math>`y`</math> се намира в долната част, то са налице два вектора с тегло <math>`2`</math> във 
                всяко комножество. Тогава случайно <math>`y`</math> може да се декодира, като кодовата дума, която е била изпратена. Например, ако е 
                приет векторът <math>`10011`</math> и са допуснати две грешки, изпратената дума може да бъде <math>`01011`</math> или <math>`10110`</math>. 
                Непълната декодираща схема е подходяща при кодове с твърде малко разстояние. Ако <math>`d(C) = 2t + 2`</math>, това гарантира да 
                се коригират до <math>`t`</math> грешки и едновременно да се открият <math>`t + 1`</math> грешки. Ако се извършва непълно декодиране със 
                синдромната претърсваща таблица стандартната решетка може да стане излишна не само в декодираща схема, но и при действителното 
                конструиране на таблицата. Това е така, защото точно са известни кои комножествените лидери са на горната част на решетката 
                (всички тези вектори с тегло <math>`≤ t`</math>), докато тези в долната част не се използват при декодирането и не е необходимо да 
                бъдат определени. С други думи съхранява се само горната част на синдромната претърсваща таблица.</p>

                <h3>Пример:</h3>
                <h3>Входни данни:</h3>
                <p align="justify"> матрица – пораждаща матрица на линейния код (матрицата не е в систематичен вид):</p>
                <br />
                <p align="center"><math>`G=((1,0,1,1,0,0,0),(0,1,0,1,1,0,0),(0,0,1,0,1,1,0),(0,0,0,1,0,1,1))`</math></p>
                <br />
                <p align="justify">Бинарен вектор с дължина <math>`N`</math>:  <math>`1 1 0 1 0 1 1`</math></p>
                <p align="justify">Генерира се спектъра на класа, той е:</p>
                <p align="justify">
                    <math>
                        `1011000, 0101100, 0010110, 0001011, 1110100, 1001110, 1010011, 0100111, 0111010, 0011101,`
                    </math>
                    <math>
                       `1100010, 1111111, 0110001, 1000101, 1101001`
                    </math>.
                </p>
                <p align="justify">Образува се проверочна матрица <math>`H`</math></p>
                <br />
                <p align="center"><math>` H=((1,1,1,0,1,0,0),(1,0,1,1,0,1,0),(1,1,0,1,0,0,1))`</math></palign="center">
                    <br />
                <p align="justify">Генерира се таблицата със синдромите, лидерите и елементите на съседните класове. Нарияа се Таблица на Слепиан:</p>
               <br/>
                 <img class="center-block img-thumbnail" src="~/Content/IMG/Table4.3.png" alt="Moderno - Theme by GraphBerry.com">
                <br />
                <p align="justify">Образува се синдрома на получения вектор <math>`Y`</math>. Това е скаларното произведение  <math>`H.Y^T`</math>. Резултът който се получава е: <math>`010`</math></p>
                <p align="justify">Това означава, че съседния клас на който принадлежи вектора <math>`Y`</math> е с номер <math>`2`</math>, позицията в която е допусната грешка е <math>`5`</math>. 
                За да се получи правилният вектор трябва да се съберат побитово сектора <math>`Y`</math> и лидера на този съседен клас. Като резултат се получава: <math>`1101001`</math>.</p>

            </div>
        </div>
    </div>
</section>
<!-- Contact section end -->
<!-- Footer start -->

