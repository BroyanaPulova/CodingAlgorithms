
@{
    ViewBag.Title = "Theory";
    Layout = "~/Views/Shared/_Layout.cshtml";
}

<div class="jumbotron home home-fullscreen" id="home">
    <div class="mask"></div>
    <a href="#" class="logo">
        <img src="~/Content/IMG/96x96.png" alt="Moderno - Theme by GraphBerry.com">
    </a>
    <!-- Offsite navigation -->
    <div class="container">
        <div class="header-info">
            <h1>ШУМОЗАЩИТНО КОДИРАНЕ</h1>
            <p>
                кодиране на информацията с цел с запазването и при предаването в каналите за връзка.
            </p>
            <a href="/Coding/Coding" class="btn btn-primary">ОЩЕ>></a>
        </div>
    </div>
</div>
<!-- Services section start -->
<!-- Services section end -->
<!-- Portfolio section start -->
<section id="portfolio" class="darker">
    <div class="container">
        <div class="panel panel-default" style="margin-right:2.5%;">
            <div class="panel-body">
                <h2>Код на Хеминг</h2>

                <p align="justify">  Кодовете на Hamming са фамилия кодове за корекции на единични грешки. Това са линейни кодове върху крайно поле `GF ( q )`. Бинарните Hamming кодове 
                се дефинират с тяхната проверочна матрица:</p>

                <h3>Дефиниция:</h3> 
                <p align="justify"> Нека r е положително цяло число и `H` е <math>`r × (2^r - 1)`</math> матрица, чиито колони са ненулеви вектори на <math>`V (r, 2)`</math>. Тогава кодът с проверочна
                матрица `H` се нарича бинарен Hamming код и се означава с <math>`Ham(r, 2)`</math>. Кодът <math>`Ham(r, 2)`</math> има дължина <math>`n = 2^r - 1`</math> 
                и размер <math>`k = n - r`</math>. Следователно <math>`r = n - k`</math> е броят на проверовъчните символи във всяка кодова дума и е известно като излишък на кода.
                </p>
                
                <p align="justify">Колоните на H могат да се вземат в произволен ред и кодът <math>`Ham(r, 2)`</math> при зададен излишък r е всеки един от определен брой еквивалентни кодове.</p>
                
                <h3>Теорема:</h3>

                <p align="justify">
                    Бинарният Hamming код <math>`Ham(r, 2)`</math> при <math>`r ≤ 2`</math> е:</p>
                    <ul>
                    <li><p align="justify"><math>`[2^r - 1, 2^r - 1 - r]`</math> код.</p></li>
                    <li><p align="justify">Има минимално разстоявние 3 (следователно това е код за корекция на единична грешка в кодовата дума).</p></li>
                    <li><p align="justify">Е префиксен код.</p></li>
                    </ul>
            
                <h3>Декодиране с бинарни Hamming кодове</h3>

                <p align="justify">Тъй като <math>`Ham(r, 2)`</math> е префиксен код за корекция на единична грешка, лидерите на ко-множествата са точно <math>`2^r = n + 1`</math>
                 вектори на <math>`V (r, 2)`</math> с тегло <math>`≤ 1`</math>. Синдромът на вектора <math>`0 … 010 … 0`</math> (с единица на j-та позиция) е <math>
                 (`0 … 010 … 0`)</math>. <math>`H^Т`</math>, Което е само транспозицията на `j`-та колона на `H`.Следователно, ако колоните на `H` са подредени в ред на 
                нарастващи бинарни числа, тоест  `j`-та  колона на `H` e бинарно представяне на числото `j`. Разширени бинарни Hamming кодове.
                </p>

                <p align="justify">Разширен бинарен Hamming код е <math>`hat(Ham) ̂(r, 2)`</math>, е код получен от <math>`Ham(r, 2)`</math> чрез добавяне на общи проверовъчни елементи.
                 Минималното разстояние нараства от 3 на 4. Разширеният код е линеен, от тук <math>`hat(Ham) ̂(r, 2)`</math> е <math>`[2^r, 2^r - 1 - r, 4]`</math> код. Разширеният код
                <math>`hat(Ham) ̂(r, 2)`</math> е не по-добър от <math>`Ham(r, 2)`</math>, когато се използва за декодиране. Допълнителните цифри за всяка кодова дума 
                намалява скоростта на предаване на информацията. При минималнo разстояние 4, <math>`hat(Ham) ̂(r, 2)`</math> е изключително подходящ за не пълно кодиране. 
                Той може едновременно да коригира всяка единична грешка и да открие двойна грешка.
                </p>

                <p align="justify"> Нека H е проверочна матрица за <math>`Ham(r, 2)`</math>. Приверочната матрица <math>`bar H`<math> за разширения код може да се получи от `H` чрез преобразуване</p>
                <br />
                <p align="center">
                    <math>`H → bar H = ((a,b,1),(c,d, ...),(1,...,1))`</math>, където <math> `((a,b),(c,d)) = H`</math>
                </p>
                <br />
                <p align="justify"> Последният ред дефинира обобщеното проверовъчно уравнение върху кодовите думи, тоест <math>`x_1 + x_2 + … + x_(n - 1) = 0 `</math>. Ако `H` се представи 
                с колони с нарастващ ред на бинарните номера, съществува точен декодиращ алгоритъм, илюстрирам за <math>`r = 3`</math>, за коригиране на единичнагрешка и 
                откриване на двойна грешка.
                </p>
                <h3>Алгоритъм:</h3>
                <p align="justify">
                    Ако се приеме вектора `Y`, то се изчислява неговият синдром <math>`S(y) = Y. H^T`</math>. Ако <math>`S(y) = 0`</math>, тогава се проема, че е изпратена 
                кодовата дума `Y`. Ако <math>`S(y) ≠ 0`</math> и се приеме единична грешка, <math>`S(y)`</math> дава бинарното представяне на позицията на грешката, 
                т.е. грешката може да бъде поправена.</p>
                <h3>Пример:</h3>
                <p align="justify">Входни данни: <br><math>`r = 4`</math> <br>Вектор <math>`Y: 110100101101000`</math><br>
                Генерира се матртицата <math>`Ham(4, 2)`</math></p>
                <br/>
                <p align="center"><math>
                        `Ham(4,2)=((0,0,0,0,0,0,0,1,1,1,1,1,1,1,1),(0,0,0,1,1,1,1,0,0,0,0,1,1,1,1),(0,1,1,0,0,1,1,0,0,1,1,0,0,1,1),(1,0,1,0,1,0,1,0,1,0,1,0,1,0,1))`
                    </math></p>
                <br />
                <p align="justify">Пресмята се синдрома на вектора `Y`,<math> `S(y) = Y.H^T`</math>
                <p align="justify"><math>`S(y) = 1111`</math>, това е десеттичния яеквивалент на числото `16 =>` грешката във вектора Y е допусната на 16-та позиция.
                </p>
                <p align="justify">  
                    От тук следва че правилният вектор Y e:  `110100101101001`
                </p>
</div>
        </div>
    </div>
</section>
<!-- Contact section end -->
<!-- Footer start -->

