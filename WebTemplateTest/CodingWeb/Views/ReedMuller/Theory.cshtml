
@{
    ViewBag.Title = "Theory";
    Layout = "~/Views/Shared/_Layout.cshtml";
}

<div class="jumbotron home home-fullscreen" id="home">
    <div class="mask"></div>
    <a href="#" class="logo">
        <img src="~/Content/IMG/96x96.png" alt="Moderno - Theme by GraphBerry.com">
    </a>
    <!-- Offsite navigation -->
    <div class="container">
        <div class="header-info">
            <h1>ШУМОЗАЩИТНО КОДИРАНЕ</h1>
            <p>
                кодиране на информацията с цел с запазването и при предаването в каналите за връзка.
            </p>
            <a href="/Coding/Coding" class="btn btn-primary">ОЩЕ>></a>
        </div>
    </div>
</div>
<!-- Services section start -->
<!-- Services section end -->
<!-- Portfolio section start -->
<section id="portfolio" class="darker">
    <div class="container">
        <div class="panel panel-default" style="margin-right:2.5%;">
            <div class="panel-body">
                <h2>Кодове на Рийд Малер</h2>
                <p align="justify">
                    Снимки от планетата Марс са първоначално направени от Mariner сериите от космически кораби през 60-те и ранните 70-те години,
                     като  е  използван Reed-Muller код с брой на кодовите думи <math>`5`</math> от  първи  ред с дължина <math>`32`</math>, за  да  се  получат  снимки  с  
                    добро  качество. Оригиналните  черно-бели снимки взети от по-ранни космически кораби Mariners са представени, като 
                    200 x 200 картинни елемента. На всеки елемент е определена двоична 6-орка, представлявайки едно от <math>`64`</math> възможни нива за яркост 
                    например от <math>`000000`</math> за бяло до <math>`111111`</math> за черно. По-късно това разпределение е направено по-точно, като се използват 700x832 елемента. 
                    Качеството се е повишило, като 6-орките са се кодирали, като се използува   <math>`[32, 6, 16]`</math> двоичен Reed-Muller код <math>`R(1, 5)`</math>, 
                    коригиращ <math>`7`</math> грешки. Същият код е използван и при цветни снимки, просто същата снимката е минала  през  различни  цветни  филтри. 
                    Във космическите кораби Voyager в края на 70-те години за  цветна  фотография е използван двоичният разширен Golay код <math>`G24 [24, 12, 8]`</math> .
                </p>
                   <h3> Reed-Muller код и кодиращи матрици.</h3>

    <p align="justify">  Reed-Muller код от <math>`r -`</math> ти ред <math>`R(r, m)`</math> е множество от всички  бинарни  вектори с дължина, свързани с булевия полином 
        <math>`p(x_1,x_2,…,x_m)`</math>    със степен най-малко r. Reed - Muller код <math>`R(0,m)`</math> от нулев ред се състои от бинарни вектори, 
                свързани  с константните полиноми  <math>`0`</math> и <math>`1`</math>, тоест     <math>`R (0, m) = {0, 1} = Rep(2^m )`</math>.</p>
    <p align="justify">  Следователно <math>`R(0, m)`</math> е код с повторение или на нули, или на  единици с дължина <math>`2^m`</math>. От друга страна Reed-Muller 
                код <math>`R(m, m)`</math> от <math>`m –`</math> ти   ред се състои от всички бинарни вектори с дължина <math>`2^m`</math>.</p>
    <p align="justify">  За да се дефинира кодиращата матрица R(r, m)`</math> се допуска, че първи  ред на кодиращата матрица е <math>`1`</math> - единичен вектор с  
                дължина <math>`2^m`</math>. Ако <math>`r = 0`</math>,  тогава първият ред е единственият в кодиращата матрица. Ако <math>`r = 1`</math>,   тогава се добавят 
        <math>`m`</math> редове, съответстващи на векторите <math>`x_1,x_2,…,x_m`</math> на кодираща матрица <math>`R(0, m)`</math>. За да се формира кодираща матрица 
        <math>`R(r, m)`</math> при <math>`r  > 1`</math>, се добавят <math>`(m¦r)`</math> редове към <math>`R(r - 1, m)`</math> кодираща матрица.</p>
    <p align="justify">  Тези добавени редове се състоят от всички възможни мономиали със степени <math>`r`</math>, които могат да бъдат формирани 
                чрез  използване  на  редовете   <math>`x_1,x_2,…,x_m`</math>.</p>
    <p align="justify">
        Кодирането на съобщенията чрез Reed-Muller е еднозначно. За да се определи кодът се използва матрицата <math>`R(r, m)`</math>. Размерът на кода в този  случай е
        <math>`k=1+(m¦1)+(m¦2)+⋯+(m¦r)`</math>
    </p>
    <p align="justify">  С други думи кодиращата матрица има <math>`k`</math> реда. Съобщението се  изпраща в блокове с дължина <math>`k`</math>.</p>
    <p align="justify">
        Нека <math>`m = (m_1,m_2,…,m_k )`</math> е информационният блок, тогава кодиращото съобщение <math>`M_C`</math> има вида
        <math>`M_C=  ∑_(i=1)^k m_i R_i`</math> 
        където <math>`R_i`</math> са редове от кодиращата матрица <math>`R(r, m)`</math>.
    </p>

                <h3>
                    Декодиране на Reed-Muller код.</h3>

    <p align="justify">   Декодирането на съобщение кодирано с Reed-Muller код е по-сложно в сравнение с процеса за кодиране. 
                Теорията на кодирането и декодирането се базира на Hamming-разстоянието между векторите. Разстоянието 
                между два вектора  е  броят  на  местата  в  двата вектора, в които имат различни стойности. Hamming-разстоянието 
                между които и да е две кодови думи в <math>`R(r, m)`</math> код е <math>`2^(r-m)`</math>. Базата за кодирането по Reed-Muller е допускането, че 
                най-близката кодова дума в <math>`R(r, m)`</math> към приетото  съобщение е оригиналното кодирано съобщение.</p>
    <p align="justify">  Следователно, за да се коригират t грешки в приетото съобщение разстоянието между 2 кои да са  кодови думи в <math>`R(r, m)`</math>
    трябва да бъде по-голямо от <math>`2t`</math>.   Декодиращият метод който се използва е доста неефективен, но твърде ясен. Той проверява 
                всеки ред в кодиращата матрица и използва мажоритарна логика за да се определи дали този ред се използва при формирането на 
                кодираното съобщение. Следователно, възможно е да се  определи какво е било кодираното съобщение с по-малко грешки и какво е 
                било оригиналното съобщение.</p>

                <h3>
                    Reed-Muller код от първи ред.</h3>

    <p align="justify">   Кодът на Reed-Muller от <math>`1-`</math>ви ред <math>`R(1, m)`</math> с дължина  е разширен  ортогонален Hamming бинарен код <math>`H ̂_m^⊥`</math>, т.е. 
                това е <math>`[2^m,m+1,2^(m-1)]`</math> бинарен  код  коригиращ  <math>`(2^(m-2) - 1)`</math> грешки. Пораждащата матрица <math>`G`</math> с  размер 
                
        <math>`6 x 32`</math> за кода на Reed-Muller <math>`R(1, 5)`</math> може да се конструира, както  следва:</p>
    <p align="justify">   Формира се матрица <math>`G_0`</math>  с размери (5 x 32) с колони, с дължина <math>`5`</math>, бинарно представящи всяко число от <math>`1`</math> до <math>`31`</math>.</p>
    <p align="justify">  Добавя се колона само с нулеви елементи и накрая се добавя <math>`6-`</math>ти ред с единични елементи.</p>

                <h3>Алгоритъм:</h3>

                <h3> Входни данни:</h3>
                <p align="justify">  r , <math>`m`</math> = целочислени, определящи кода</p>
                <p align="justify">  Y – бинарен вектор, който трябва да се кодира или да се поправи решката в него.</p>
                <p align="justify">  Генерира се матрицата <math>`RM(r,m)`</math></p>
                <h3> Кодиране:</h3>
                <p align="justify">  Въвежда се вектор <math>`Y`</math> с дължина равна на броя на редовете с пораждащата матрица.</p>
                <p align="justify">  Редовете на матрицата се умножават с елементите на вектора.</p>
                <p align="justify">  За получаване на кодираното съобщение резултата от умножението се събира побитово.</p>
                <h3>Декодиране (поправяне на грешка):</h3>
                <p align="justify">   2. Редовете на матрицата се означават съответно с: 
                    <math>`1,x_1,x_2,…,x_k,…,x_1+x_2+ x_r,(∀ C_k^r)`</math>.</p>
                <p align="justify"> 3. Започвайки от последния ред на матрицата към <math>`x_1`</math>, 
                за всеки от редовете се образуват всички комбинации на неучастващите в многочлена едночлвни и техните отрицания.</p>
                <p align="justify">  4. За всяка от получениете комбинации се пресмята побитовия <math>`AND`</math> на участващите 
                вектори (или съответните им отрицания)</p>
                <p align="justify">  5. Резилтата се умножава скаларно с въведения вектор <math>`Y`</math>.</p>
                <p align="justify">  Ако браоят на получените едини е четно число запазваме като резултат <math>`0`</math>.</p>
                <p align="justify">  В противен случай запазваме <math>`1`</math>.</p>
                <p align="justify"> Полученият бинарен вектор сенарича характеристичен 
                (за всеки ред от матрицата има по един такъв вектор).</p>
                <p align="justify"> 6. Ако единиците в характеристичния вектор са повече нулите, то реда на 
                който съответства този вектор участва в кодовото съобшение. В противен случай не участва.</p>
                <p align="justify">  7.Това се извършва за всеки ред от пораждащата матрица с изключение на ред <math>`1`</math>.</p>
                <p align="justify">  8. След като всички участващи в съобщението вектори са определени, те се събират побитово. 
                След събирането се получава вектор.</p>
                <p align="justify">  9. Ако теглото на получения вектор е <math>`≤`</math> на половината от дължината на кодовата дума, 
                това е правилният вектор. В противен случай за да получем правилния вектор, към него се добавя едничиния вектор.</p>
                <h3>Пример:</h3>
                <br />
                <h3>Кодиране:</h3>
                <br />
                <h3> Входни данни:</h3>
                <p align="justify">  <math>`r = 1, m = 3`</math></p>
                <p align="justify">  <math>`y = 1010`</math></p>
                <p align="justify">  Образува се пораждащата матрица на кода <math>`RM(1,3)`</math></p>
                <br/>
                <p align="center"> <math>`G=((1,1,1,1,1,1,1,1),(0,0,0,0,1,1,1,1),(0,0,1,1,0,0,1,1),(0,1,0,1,0,1,0,1))`</math></p>
                <br />
                <p align="justify"> Редовете на матрицата се ъмножават с елементите на входното съобщение <math>`y`</math> и 
                резултата се сумира:</p>
                <br />
                <p align="justify"> <math>`11111111*1 + 00001111*0 + 00110011*1 + 01010101*0 = 11111111 + 00110011 = 11001100`</math></p>
                <br />
                <p align="justify"> Кодираното съобщение е <math>`11001100`</math>.</p>

                <h3>Декодиране:</h3>
                <br />
                <h3>Входни данни:</h3>
                <p align="justify"> <math>`Y =10111010`</math></p>
                <p align="justify"> <math>`r = 1, m = 4`</math>; тоест матрицата която е използвана в примера за кодиране.</p>
                <p align="justify"> Редовете на матрицата се обозначават по следния начин:</p>
                <br />
                <p align="justify"> <math>`1  1  1  1  1  1  1  1=1`</math></p>
                <p align="justify"> <math>`0  0  0  0  1  1  1  1= x_1`</math></p>
                <p align="justify"> <math>`0  0  1  1  0  0  1  1= x_2`</math></p>
                <p align="justify"> <math>` 0  1  0  1  0  1  0  1= x_3`</math></p>
                <br />
                <p align="justify"> Образуват се съответните комбинации за всеки от редовете:</p>
                <br />
                <p align="justify"> За ред <math>`x_3`</math>:</p>
                <br />
                <p align="justify"> <math>`x_1&x_2= 00000011 = h_1     →  h_1.Y=00000010=1`</math></p>
                <p align="justify"> <math>`x_1&bar(x_2 )= 00001100 = h_2     →  h_2.Y=00001000=1`</math></p>
                <p align="justify"> <math>`bar(x_1 )&x_2= 00110000 = h_3     →  h_3.Y=00110000=0`</math></p>
                <p align="justify"> <math>`bar(x_1 )&bar(x_2 )=11000000 = h_4      →  h_1.Y=10000000=1`</math></p>
                <br />
                <p align="justify">  Получения характеристичен вектор е <math>`1101`</math>, има повече единици от колкото нули, 
                следователно реда  <math>`x_3`</math> участва в кодовото съобщение.</p>
                <br />
                <p align="justify"> За ред <math>`x_2`</math>:</p>
                <br />
                <p align="justify"> <math>`x_1&x_3= 00000101 = h_1     →  h_1.Y=00000000=0`</math></p>
                <p align="justify"> <math>`x_1&bar(x_3 )= 00010100 = h_2     →  h_2.Y=00010000=1`</math></p>
                <p align="justify"> <math>`bar(x_1 )&x_3= 01010000 = h_3     →  h_3.Y=00010000=0`</math></p>
                <p align="justify"> <math>`bar(x_1 )&bar(x_3 )=10100000 = h_4      →  h_1.Y=10100000=0`</math></p>
                <br />
                <p align="justify">  Получения характеристичен вектор е <math>`0100`</math>, има повече нули от колкото единици, 
                следователно реда  <math>`x_2`</math>  не участва в кодовото съобщение.</p>
                <br />
                <p align="justify">  За ред <math>`x_1`</math>:</p>
                <br />
                <p align="justify"> <math>`x_2&x_3= 00010001 = h_1     →  h_1.Y=00010000=1`</math></p>
                <p align="justify"> <math>`x_2&bar(x_3 )= 00100010 = h_2     →  h_2.Y=00100010=0`</math></p>
                <p align="justify"> <math>`bar(x_2 )&x_3= 01000100 = h_3     →  h_3.Y=00000000=0`</math></p>
                <p align="justify"> <math>`bar(x_2 )&bar(x_3 )=10001000 = h_4      →  h_1.Y=10001000=0`</math></p>
                <br />
                <p align="justify">  Получения характеристичен вектор е <math>`1000`</math>, има повече нули от колкото единици, 
                следователно реда  <math>`x_1`</math>  не участва в кодовото съобщение.</p>
                <p align="justify">  Вектора който се получава е равен на <math>`x_1*0+x_2*0+x_3*1=01010101`</math>, 
                теглото на този векотор е равно на <math>`n/2`</math> т.е на <math>`4`</math>. Следователно към него трябва да се добави 
                единичния вектор. Като краен резултат от алгоритъма се получава <math>`10101010`</math>. Това е правилният изпратен вектор.</p>

</div>
        </div>
    </div>
</section>
<!-- Contact section end -->
<!-- Footer start -->
